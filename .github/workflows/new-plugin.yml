name: new-plugin
on:
  push:
    branch:
      - "main"
    paths:
      - "plugins/**"

# Prevent running this workflow concurrently
concurrency:
  group: "matrix-messages"

jobs:
  setup:
    name: Collect metadata and setup job matrix
    runs-on: ubuntu-latest
    timeout-minutes: 40
    if: github.repository == 'nix-community/nixvim'

    outputs:
      plugins: ${{ steps.get_info.outputs.json }}
      pr_number: ${{ steps.pr.outputs.number }}
      pr_url: ${{ steps.get_pr.outputs.url }}
      pr_author_name: ${{ steps.get_pr.outputs.author_name }}
      pr_author_url: ${{ steps.get_pr.outputs.author_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v26
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get plugins info
        id: get_info
        run: |
          # Use `nix eval` to get json arrays containing plugins available on the pushed commit, and the previous commit
          OLD_PLUGINS=$(
            nix eval 'github:${{ github.repository }}/${{ github.event.before }}#nixvimConfiguration.options.plugins' \
              --apply 'builtins.attrNames' \
              --json
          )
          NEW_PLUGINS=$(
            nix eval '.#nixvimConfiguration.options.plugins' \
              --apply 'builtins.attrNames' \
              --json
          )
          OLD_COLORSCHEMES=$(
            nix eval 'github:${{ github.repository }}/${{ github.event.before }}#nixvimConfiguration.options.colorschemes' \
              --apply 'builtins.attrNames' \
              --json
          )
          NEW_COLORSCHEMES=$(
            nix eval '.#nixvimConfiguration.options.colorschemes' \
              --apply 'builtins.attrNames' \
              --json
          )
          PLUGIN_JSON="{ \"old\": $OLD_PLUGINS, \"new\": $NEW_PLUGINS }"
          COLORSCHEME_JSON="{ \"old\": $OLD_COLORSCHEMES, \"new\": $NEW_COLORSCHEMES }"

          # Collect added/removed plugins by subtracting old/new arrays
          GROUPED="{
            \"added\": {
              \"plugin\": $(echo "$PLUGIN_JSON" | jq '.new-.old'),
              \"colorscheme\": $(echo "$COLORSCHEME_JSON" | jq '.new-.old')
            },
            \"removed\": {
              \"plugin\": $(echo "$PLUGIN_JSON" | jq '.old-.new'),
              \"colorscheme\": $(echo "$COLORSCHEME_JSON" | jq '.old-.new')
            }
          }"

          # Un-group types to `{ "added": [ { "type": "plugin", "name": "foo" } ], "removed": [] }`
          GROUPED_BY_CHANGE=$(echo "$GROUPED" | jq -c 'map_values(to_entries | map(.key as $type | .value[] | { type: $type, name: . }))')
          # TODO: When plugins are removed, try to detect renames heuristically

          # Write to GITHUB_OUTPUT
          JSON=$(echo "$GROUPED_BY_CHANGE" | jq -c 'to_entries | map(.key as $change | .value[] | . += { change: $change })')
          echo "json=$JSON" >> $GITHUB_OUTPUT

      - name: Get PR info
        id: get_pr
        if: steps.get_info.outputs.json != '[]'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # `gh` will have already printed to stderr, so no need to parse the response json
          JSON=$(
            gh api  \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/commits/${{ github.sha }}/pulls
          ) || exit 1

          if [[ "$(echo "$JSON" | jq -c '.')" = "[]" ]]; then
            # No associated PR
            # TODO: does this need special handling?
          else
            # Print key=value pairs to GITHUB_OUTPUT
            echo "$JSON" | \
              jq -r '.[0] | { number: .number, url: .html_url, author_name: .user.login, author_url: .user.html_url } | to_entries[] | "\(.key)=\(.value)"' \
              >> $GITHUB_OUTPUT
          fi

  send:
    name: Send matrix message
    runs-on: ubuntu-latest
    needs: setup
    strategy:
      matrix:
        plugins: ${{ fromJSON(needs.setup.outputs.plugins) }}
    env:
      name: ${{ matrix.plugins.name }}
      type: ${{ matrix.plugins.type }}
      change: ${{ matrix.plugins.change }}
      pr_number: ${{ needs.setup.outputs.pr_number }}
      pr_url: ${{ needs.setupt_pr.outputs.pr_url }}
      pr_author_name: ${{ needs.setupt_pr.outputs.pr_author_name }}
      pr_author_url: ${{ needs.setupt_pr.outputs.pr_author_url }}

    steps:
      - name: Install matrix-msg tool
        uses: lkiesow/matrix-notification@v1
        with:
          token: ${{ secrets.CI_MATRIX_TOKEN }}
          server: ${{ secrets.CI_MATRIX_SERVER }}
          room: ${{ secrets.CI_MATRIX_ROOM }}
          tool: true

      - name: Send message and print summary
        run: |
          # Message text; plain-text & html
          # TODO: format as-per existing announcements
          # See available env-vars above
          msg="Hello, world!"
          html_msg="Hello, <b>world!</b>"

          # stdout
          echo "$msg"

          # markdown summary
          echo "$html_msg" >> $GITHUG_STEP_SUMMARY

          # matrix message
          matrix-msg "$msg" "$html_msg"
          # TODO: update stdout/step_summary with msg success/failure
